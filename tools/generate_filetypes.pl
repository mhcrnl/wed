#!/usr/bin/perl

# 
# Copyright (C) 2016 Richard Burke
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#

use strict;
use warnings;

use Getopt::Long qw(GetOptions);
use File::Basename qw(fileparse);

main();

sub main {
    my $opt = get_opt();
    my $lang_map = load_lang_map($opt);
    write_filetypes($opt, $lang_map);
}

sub usage {
    my $opt = shift;

    print "
$opt->{script}: [OPTIONS] FILEPATH

FILEPATH:
File path to the source-highlight lang.map file.

OPTIONS:
--output-file,-o        Output file path filetype definitions are written to.
                        Default: $opt->{output_file}

";
    exit 1;
}

sub get_opt {
    my %opt = (
        output_file => 'filetypes.wed'
    );

    my ($script_name) = fileparse(__FILE__);
    $opt{script} = $script_name;

    GetOptions('output-file|o=s' => \$opt{output_file});

    if (scalar(@ARGV) < 1) {
        usage(\%opt);
    }

    $opt{input_file} = $ARGV[0];

    return \%opt;
}

sub load_lang_map {
    my $opt = shift;

    open(my $fh, '<', $opt->{input_file}) ||
        die "Couldn't open file \"$opt->{input_file}\" for reading: $!";

    my %lang_map;

    while (my $line = <$fh>) {
        if ($line =~ /^\s*(\S+)\s*=\s*(\S+)\.lang\s*$/) {
            if (!exists($lang_map{$2})) {
                $lang_map{$2} = [];
            } 

            push(@{$lang_map{$2}}, $1);
        } 
    }

    close($fh);

    return \%lang_map;
}

sub write_filetypes {
    my ($opt, $lang_map) = @_;

    open(my $fh, '>', $opt->{output_file}) ||
        die "Couldn't open file \"$opt->{output_file}\" for writing: $!";

    printf $fh "# Generated by $opt->{script}\n";

    my @langs = sort(keys %$lang_map);

    for my $lang (@langs) {
        print $fh generate_filetype_def($lang, $lang_map->{$lang}); 
    }

    close($fh);
}

sub generate_filetype_def {
    my ($lang, $file_extensions) = @_;

    my @escaped_file_ext = map { quotemeta($_) } @$file_extensions;
    my $filetype_regex;

    if (scalar(@escaped_file_ext) == 1) {
        $filetype_regex = $escaped_file_ext[0];
    } else {
        $filetype_regex = '(' . join('|', @escaped_file_ext) . ')';
    }

    $filetype_regex = '/\.' . $filetype_regex . '$/';

    return "
filetype {
	name = \"$lang\";
	display_name = \"$lang\";
	file_pattern = $filetype_regex;
}
";
}

